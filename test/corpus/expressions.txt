======
Number
======

#eval 2

---

(source_file (hash_command (number)))

======
String
======

#eval "foo"

---

(source_file (hash_command (string)))

====
List
====

#check [1, 2, 3]
#check []

---

(source_file
  (hash_command (list (number) (number) (number)))
  (hash_command (list)))

===================
Unicode Identifiers
===================

#eval foo₁

---

(source_file (hash_command (identifier)))

=======
Product
=======

#check (10, "foo", 30, 40)

---

(source_file (hash_command (product (number) (string) (number) (number))))

=======
If/Then
=======

#eval if true then "foo"

---

(source_file (hash_command (conditional (true) (string))))

============
If/Then/Else
============

#eval if true then "foo" else "bar"

---

(source_file (hash_command (conditional (true) (string) (string))))

===================
Nested If/Then/Else
===================

#eval if true then if false then "foo" else "bar" else "baz"

---

(source_file
  (hash_command
    (conditional (true)
      (conditional (false) (string) (string))
      (string))))

========
Negation
========

#eval !true
#eval !!!true

---

(source_file
  (hash_command (unary_expression (true)))
  (hash_command
    (unary_expression (unary_expression (unary_expression (true))))))

==================
Binary Expressions
==================

#eval 2 + 3
#eval 2 - 3
#eval 2 = 3
#eval 2 ≠ 3
#eval "foo" ++ "bar"
#eval [] :: [["foo"]]

---

(source_file
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (string) (string)))
  (hash_command (binary_expression (list) (list (list (string))))))

==========
Comparison
==========

#eval 2 < 3
#eval 2 > 3

---

(source_file
  (hash_command (comparison (number) (number)))
  (hash_command (comparison (number) (number))))

=====================
Comparison Precedence
=====================

#check id 2 < 3

---

(source_file (hash_command
  (comparison
    (apply (identifier) (number))
    (number))))

===========================
Multiple Function Arguments
===========================

#check foo 2 3 4

---

(source_file
  (hash_command
    (apply (identifier) (number) (number) (number))))

===============
Named Arguments
===============

#check foo (bar := 3)

---

(source_file
  (hash_command
    (apply (identifier) (named_argument (identifier) (number)))))

=====================
Mixed Named Arguments
=====================

#check foo 1 (bar := 3) 2 (baz := 4)

---

(source_file
  (hash_command
    (apply (identifier)
        (number)
        (named_argument (identifier) (number))
        (number)
        (named_argument (identifier) (number)))))

============
Field Access
============

#check FooBar.foo

---

(source_file
  (hash_command (element_of (identifier) (identifier))))

===================
Nested Field Access
===================

#check Foo.bar.baz.quux

---

(source_file
  (hash_command
    (element_of
      (element_of
        (element_of (identifier) (identifier))
        (identifier))
      (identifier))))

=======================
Expression Field Access
=======================

#check (Foo.bar baz).baz

---

(source_file
  (hash_command
    (element_of
      (apply (element_of (identifier) (identifier)) (identifier))
      (identifier))))

=====
Match
=====

def foo (d : Bar) : Baz :=
  match d with
  | quux => 1

---

(source_file
  (def
    name: (identifier)
    parameters: (parameter_list (annotated (identifier) (identifier)))
    return_type: (identifier)
    body:
      (match (identifier)
        patterns: (pattern (identifier) (number)))))

==================
Match Syntax Sugar
==================

def foo : Nat → Nat
  | 0 => 2
  | 2 => 3
  | _ => 5

---

(source_file
  (def
    name: (identifier)
    return_type: (function_annotation (identifier) (identifier))
    body: (pattern (number) (number))
    body: (pattern (number) (number))
    body: (pattern (identifier) (number))))

==================
Multimatch Syntax Sugar
==================

def foo : Nat → Nat -> Nat
  | 0, foo => 2
  | 2, bar => 3
  | _, _ => 5

---

(source_file
  (def
    name: (identifier)
    return_type: (function_annotation (identifier) (identifier) (identifier))
    body: (pattern (lhs (number) (identifier)) (number))
    body: (pattern (lhs (number) (identifier)) (number))
    body: (pattern (lhs (identifier) (identifier)) (number))))

=============
$ Application
=============

#eval foo bar (baz (1 + 1))
#eval foo bar $ baz (1 + 1)
#eval foo bar $ baz $ 1 + 1

---

(source_file
  (hash_command
    (apply (identifier) (identifier)
      (apply (identifier) (binary_expression (number) (number)))))
  (hash_command
    (apply (apply (identifier) (identifier))
      (apply (identifier) (binary_expression (number) (number)))))
  (hash_command
    (apply (apply (identifier) (identifier))
      (apply (identifier) (binary_expression (number) (number))))))
