======
Number
======

#eval 2

---

(source_file (hash_command (number)))

======
String
======

#eval "foo"

---

(source_file (hash_command (string)))

====
Char
====

#eval 'f'

---

(source_file (hash_command (char)))

========
Non-Char
========

#eval 'fa'

---

(source_file (hash_command (char (ERROR (identifier)))))

====
List
====

#check [1, 2, 3]
#check []

---

(source_file
  (hash_command (list (number) (number) (number)))
  (hash_command (list)))

=====================
Inductive Constructor
=====================

example : Foo := ⟨1, 2, 3⟩
example : Foo := ⟨1⟩
example : Foo := ⟨⟩

---

(source_file
  (example (identifier) (inductive_constructor (number) (number) (number)))
  (example (identifier) (inductive_constructor (number)))
  (example (identifier) (inductive_constructor)))

===================
Unicode Identifiers
===================

#eval foo₁

---

(source_file (hash_command (identifier)))

=======
Product
=======

#check (10, "foo", 30, 40)

---

(source_file (hash_command (product (number) (string) (number) (number))))

=======
If/Then
=======

#eval if true then "foo"

---

(source_file (hash_command (conditional (true) (string))))

============
If/Then/Else
============

#eval if true then "foo" else "bar"

---

(source_file (hash_command (conditional (true) (string) (string))))

===================
Nested If/Then/Else
===================

#eval if true then if false then "foo" else "bar" else "baz"

---

(source_file
  (hash_command
    (conditional (true)
      (conditional (false) (string) (string))
      (string))))

========
Negation
========

#eval !true
#eval !!!true

---

(source_file
  (hash_command (unary_expression (true)))
  (hash_command
    (unary_expression (unary_expression (unary_expression (true))))))

==================
Binary Expressions
==================

#eval 2 + 3
#eval 2 - 3
#eval 2 = 3
#eval 2 ≠ 3
#eval "foo" ++ "bar"
#eval [] :: [["foo"]]
#eval foo <|> bar

---

(source_file
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (string) (string)))
  (hash_command (binary_expression (list) (list (list (string)))))
  (hash_command (binary_expression (identifier) (identifier))))

==========
Comparison
==========

#eval 2 < 3
#eval 2 > 3

---

(source_file
  (hash_command (comparison (number) (number)))
  (hash_command (comparison (number) (number))))

=====================
Comparison Precedence
=====================

#check id 2 < 3

---

(source_file (hash_command
  (comparison
    (apply (identifier) (number))
    (number))))

===========================
Multiple Function Arguments
===========================

#check foo 2 3 4

---

(source_file
  (hash_command
    (apply (identifier) (number) (number) (number))))

===============
Named Arguments
===============

#check foo (bar := 3)

---

(source_file
  (hash_command
    (apply (identifier) (named_argument (identifier) (number)))))

=====================
Mixed Named Arguments
=====================

#check foo 1 (bar := 3) 2 (baz := 4)

---

(source_file
  (hash_command
    (apply (identifier)
        (number)
        (named_argument (identifier) (number))
        (number)
        (named_argument (identifier) (number)))))

============
Field Access
============

#check FooBar.foo

---

(source_file
  (hash_command
    (field_of
      term: (identifier)
      name: (identifier))))

===================
Nested Field Access
===================

#check Foo.bar.baz.quux

---

(source_file
  (hash_command
    (field_of
      (field_of
        (field_of (identifier) (identifier))
        (identifier))
      (identifier))))

=======================
Expression Field Access
=======================

#check (Foo.bar baz).baz

---

(source_file
  (hash_command
    (field_of
      (apply (field_of (identifier) (identifier)) (identifier))
      (identifier))))

=====
Match
=====

def foo (d : Bar) : Baz :=
  match d with
  | quux => 1

---

(source_file
  (def
    name: (identifier)
    parameters: (parameters (annotated (identifier) (identifier)))
    return_type: (identifier)
    body:
      (match
        value: (identifier)
        patterns: (pattern (identifier) (number)))))

================
Match Expression
================

#eval match Nat.succ 3 with
  | _ => true

---

(source_file
  (hash_command
    (match
      value:
        (apply
          name:
            (field_of
              term: (identifier)
              name: (identifier))
          arguments: (number))
      patterns: (pattern (identifier) (true)))))

==================
Match Syntax Sugar
==================

def foo : Nat → Nat
  | 0 => 2
  | 2 => 3
  | _ => 5

---

(source_file
  (def
    name: (identifier)
    return_type: (function_annotation (identifier) (identifier))
    body: (pattern (number) (number))
    body: (pattern (number) (number))
    body: (pattern (identifier) (number))))

==================
Multimatch Syntax Sugar
==================

def foo : Nat → Nat -> Nat
  | 0, foo => 2
  | 2, bar => 3
  | _, _ => 5

---

(source_file
  (def
    name: (identifier)
    return_type: (function_annotation (identifier) (identifier) (identifier))
    body: (pattern (lhs (number) (identifier)) (number))
    body: (pattern (lhs (number) (identifier)) (number))
    body: (pattern (lhs (identifier) (identifier)) (number))))

=============
$ Application
=============

#eval foo bar (baz (1 + 1))
#eval foo bar $ baz (1 + 1)
#eval foo bar $ baz $ 1 + 1

---

(source_file
  (hash_command
    (apply (identifier) (identifier)
      (apply (identifier) (binary_expression (number) (number)))))
  (hash_command
    (apply (apply (identifier) (identifier))
      (apply (identifier) (binary_expression (number) (number)))))
  (hash_command
    (apply (apply (identifier) (identifier))
      (apply (identifier) (binary_expression (number) (number))))))

==================
Anonymous Function
==================

#check fun x => x + 2

---

(source_file
  (hash_command
    (lambda
      (parameters (identifier))
      (binary_expression (identifier) (number)))))

==================
Anonymous Function
==================

#check λ x => x

---

(source_file
  (hash_command
    (lambda (parameters (identifier)) (identifier))))

==============================
Anonymous Function Application
==============================

#eval (fun x => x + 2) 10

---

(source_file
  (hash_command
    (apply
      (lambda
        (parameters (identifier))
        (binary_expression (identifier) (number)))
      (number))))
