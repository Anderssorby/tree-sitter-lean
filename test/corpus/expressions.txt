======
Number
======

#eval 2

---

(module (hash_command (number)))

=====
Float
=====

#eval 23.279
#eval 2.

---

(module (hash_command (float)) (hash_command (float)))

======
String
======

#eval "foo"

---

(module (hash_command (string)))

====
Char
====

#eval 'f'

---

(module (hash_command (char)))

========
Non-Char
========

#eval 'fa'

---

(module (hash_command (ERROR) (identifier)))

=====
Range
=====

#check [0:foo 3:1]

---

(module
  (hash_command
    (range
      start: (number)
      stop:
        (apply
          name: (identifier)
          arguments: (number))
      step: (number))))

=============
Range No Step
=============

#check [0:10]

---

(module
  (hash_command
    (range
      start: (number)
      stop: (number))))

=============
Range No Start
=============

#check [:3]

---

(module
  (hash_command
    (range
      stop: (number))))

====
List
====

#check [1, 2, 3]
#check []

---

(module
  (hash_command (list (number) (number) (number)))
  (hash_command (list)))

=====
Index
=====

#check foo[bar 3]

---

(module
  (hash_command
    (index
      container: (identifier)
      value:
        (apply
          name: (identifier)
          arguments: (number)))))

=====
Slice
=====

#check foo[0:bar 3]

---

(module
  (hash_command
    (index
      container: (identifier)
      start: (number)
      stop:
        (apply
          name: (identifier)
          arguments: (number)))))

=============
Slice No Stop
=============

#check foo[0:]

---

(module
  (hash_command
    (index
      container: (identifier)
      start: (number))))

=============
Slice No Start
=============

#check foo[:3]

---

(module
  (hash_command
    (index
      container: (identifier)
      stop: (number))))

==================
Sliced Expression
==================

#check (foo 37)[:3]

---

(module
  (hash_command
    (index
      container:
        (apply
          name: (identifier)
          arguments: (number))
      stop: (number))))

========================
Slice Does Not Have Step
========================

#check foo[1:2:3]

---

(module
  (hash_command
    (index
      (identifier) (number) (apply (number) (ERROR) (number)))))

========================
Slice Does Not Have Copy
========================

#check foo[:]

---

(module
  (hash_command
    (index
      (identifier) (do (MISSING "do")))))

===============
Slice vs. Range
===============

#check foo [1:2]

---

(module
  (hash_command
    (apply
      name: (identifier)
      arguments:
        (range
          start: (number)
          stop: (number)))))

=====
Array
=====

#check #[1, 2, 3]
#check #[]

---

(module
  (hash_command (array (number) (number) (number)))
  (hash_command (array)))

=====================
Inductive Constructor
=====================

example : Foo := ⟨1, 2, 3⟩
example : Foo := ⟨1⟩
example : Foo := ⟨⟩

---

(module
  (example (identifier) (inductive_constructor (number) (number) (number)))
  (example (identifier) (inductive_constructor (number)))
  (example (identifier) (inductive_constructor)))

===================
Unicode Identifiers
===================

#eval foo₁
#eval x'

---

(module
  (hash_command (identifier))
  (hash_command (identifier)))

===============
Non-Identifiers
===============

#eval 'x

---

(module (hash_command (char (MISSING "'"))))

=======
Product
=======

#check (10, "foo", 30, 40)

---

(module (hash_command (product (number) (string) (number) (number))))

=============
Function Type
=============

#check foo → bar
#check foo → bar → baz

---

(module
  (hash_command (function_type (identifier) (identifier)))
  (hash_command (function_type (identifier) (identifier) (identifier))))

============
Product Type
============

#check a × b
#check a × b × c

---

(module
  (hash_command (product_type (identifier) (identifier)))
  (hash_command (product_type (identifier) (identifier) (identifier))))

============
If/Then/Else
============

#eval if true then "foo" else "bar"

---

(module (hash_command (conditional (true) (string) (string))))

=============
If Needs Else
=============

#eval if true then "foo"

---

(module (ERROR (true) (string)))

===================
Nested If/Then/Else
===================

#eval if true then if false then "foo" else "bar" else "baz"

---

(module
  (hash_command
    (conditional (true)
      (conditional (false) (string) (string))
      (string))))

========
Negation
========

#eval !true
#eval !!!true
#eval !foo

---

(module
  (hash_command (unary_expression (true)))
  (hash_command
    (unary_expression (unary_expression (unary_expression (true)))))
  (hash_command (unary_expression (identifier))))

==================
Binary Expressions
==================

#eval 2 + 3
#eval 2 - 3
#eval 2 * 3
#eval 2 / 3
#eval 2 % 3
#eval 2 ^ 3
#eval 2 = 3
#eval 2 ≠ 3
#eval true ∧ true
#eval true ∨ true
#eval true ↔ true
#eval true && true
#eval true || true
#eval "foo" ++ "bar"
#eval [] :: [["foo"]]
#eval foo <|> bar
#eval 'B' == 'B' || 'B' == 'C'

---

(module
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (number) (number)))
  (hash_command (binary_expression (true) (true)))
  (hash_command (binary_expression (true) (true)))
  (hash_command (binary_expression (true) (true)))
  (hash_command (binary_expression (true) (true)))
  (hash_command (binary_expression (true) (true)))
  (hash_command (binary_expression (string) (string)))
  (hash_command (binary_expression (list) (list (list (string)))))
  (hash_command (binary_expression (identifier) (identifier)))
  (hash_command
    (binary_expression
      (binary_expression (char) (char))
      (binary_expression (char) (char)))))

==========
Precedence
==========

#eval 4 == 4 - 0
#eval 4 == 3 + 1
#eval 4 == 4 * 1
#eval 4 == 4 / 1
#eval 4 == 4 % 5
example : 4 = 4 - 0 := rfl
example : 4 = 3 + 1 := rfl
example : 4 = 4 * 1 := rfl
example : 4 = 4 / 1 := rfl
example : 4 = 4 % 5 := rfl
#eval false && false || true
#eval true || false && false
#eval 2 ^ 3 * 7 + 2

---

(module
  (hash_command
    (binary_expression (number) (binary_expression (number) (number))))
  (hash_command
    (binary_expression (number) (binary_expression (number) (number))))
  (hash_command
    (binary_expression (number) (binary_expression (number) (number))))
  (hash_command
    (binary_expression (number) (binary_expression (number) (number))))
  (hash_command
    (binary_expression (number) (binary_expression (number) (number))))
  (example
    type:
      (binary_expression (number) (binary_expression (number) (number)))
    body:
      (identifier))
  (example
    type:
      (binary_expression (number) (binary_expression (number) (number)))
    body:
      (identifier))
  (example
    type:
      (binary_expression (number) (binary_expression (number) (number)))
    body:
      (identifier))
  (example
    type:
      (binary_expression (number) (binary_expression (number) (number)))
    body:
      (identifier))
  (example
    type:
      (binary_expression (number) (binary_expression (number) (number)))
    body:
      (identifier))
  (hash_command
    (binary_expression (binary_expression (false) (false)) (true)))
  (hash_command
    (binary_expression (true) (binary_expression (false) (false))))
  (hash_command
    (binary_expression
      (binary_expression
        (binary_expression (number) (number))
        (number))
      (number))))

==========
Comparison
==========

#eval 2 < 3
#eval 2 > 3

---

(module
  (hash_command (comparison (number) (number)))
  (hash_command (comparison (number) (number))))

=====================
Comparison Precedence
=====================

#check id 2 < 3

---

(module (hash_command
  (comparison
    (apply (identifier) (number))
    (number))))

===========================
Multiple Function Arguments
===========================

#check foo 2 3 4

---

(module
  (hash_command
    (apply (identifier) (number) (number) (number))))

===============
Named Arguments
===============

#check foo (bar := 3)

---

(module
  (hash_command
    (apply (identifier) (named_argument (identifier) (number)))))

=====================
Mixed Named Arguments
=====================

#check foo 1 (bar := 3) 2 (baz := 4)

---

(module
  (hash_command
    (apply (identifier)
        (number)
        (named_argument (identifier) (number))
        (number)
        (named_argument (identifier) (number)))))

============
Field Access
============

#check FooBar.foo

---

(module
  (hash_command
    (field_of
      term: (identifier)
      name: (identifier))))

===================
Nested Field Access
===================

#check Foo.bar.baz.quux

---

(module
  (hash_command
    (field_of
      (field_of
        (field_of (identifier) (identifier))
        (identifier))
      (identifier))))

=======================
Expression Field Access
=======================

#check (Foo.bar baz).baz

---

(module
  (hash_command
    (field_of
      (apply (field_of (identifier) (identifier)) (identifier))
      (identifier))))

=====
Match
=====

def foo (d : Bar) : Baz :=
  match d with
  | quux => 1

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    return_type: (identifier)
    body:
      (match
        value: (identifier)
        patterns: (pattern (identifier) (number)))))

================
Match Expression
================

#eval match Nat.succ 3 with
  | _ => true

---

(module
  (hash_command
    (match
      value:
        (apply
          name:
            (field_of
              term: (identifier)
              name: (identifier))
          arguments: (number))
      patterns: (pattern (identifier) (true)))))

==================
Match Syntax Sugar
==================

def foo : Nat → Nat
  | 0 => 2
  | 2 => 3
  | _ => 5

---

(module
  (def
    name: (identifier)
    return_type: (function_type (identifier) (identifier))
    body: (pattern (number) (number))
    body: (pattern (number) (number))
    body: (pattern (identifier) (number))))

==========================================
Match Syntax Sugar With Anonymous Function
==========================================

def foo : Nat -> Bool :=
  fun
    | 0 => true
    | _ => false

---

(module
  (def
    name: (identifier)
    return_type: (function_type (identifier) (identifier))
    body:
      (lambda
        (pattern (number) (true))
        (pattern (identifier) (false)))))

=======================
Multimatch Syntax Sugar
=======================

def foo : Nat → Nat -> Nat
  | 0, foo => 2
  | 2, bar => 3
  | _, _ => 5

---

(module
  (def
    name: (identifier)
    return_type: (function_type (identifier) (identifier) (identifier))
    body: (pattern (lhs (number) (identifier)) (number))
    body: (pattern (lhs (number) (identifier)) (number))
    body: (pattern (lhs (identifier) (identifier)) (number))))

=============
$ Application
=============

#eval foo bar (baz (1 + 1))
#eval foo bar $ baz (1 + 1)
#eval foo bar $ baz $ 1 + 1

---

(module
  (hash_command
    (apply (identifier) (identifier)
      (apply (identifier) (binary_expression (number) (number)))))
  (hash_command
    (apply (apply (identifier) (identifier))
      (apply (identifier) (binary_expression (number) (number)))))
  (hash_command
    (apply (apply (identifier) (identifier))
      (apply (identifier) (binary_expression (number) (number))))))

==================
Anonymous Function
==================

#check fun x => x + 2

---

(module
  (hash_command
    (lambda
      (parameters (identifier))
      (binary_expression (identifier) (number)))))

=============================
Anonymous Function via Lambda
=============================

#check λ x => x

---

(module
  (hash_command
    (lambda (parameters (identifier)) (identifier))))

==============================
Anonymous Function Application
==============================

#eval (fun x => x + 2) 10

---

(module
  (hash_command
    (apply
      (lambda
        (parameters (identifier))
        (binary_expression (identifier) (number)))
      (number))))

=================================================
Anonymous Function Match With Additional Argument
=================================================

#eval foo 0 fun
  | 0 => 0
  | n => 1
  37

---

(module
  (hash_command
    (apply
      name: (identifier)
      arguments: (number)
      arguments:
        (lambda
          (pattern (number) (number))
          (pattern (identifier) (number)))
      arguments:
        (number))))

=================
Explicit Function
=================

#check @ident
#check @ident α
#check @ident Bool true
#check @foo.bar

---

(module
  (hash_command (explicit (identifier)))
  (hash_command (apply (explicit (identifier)) (identifier)))
  (hash_command (apply (explicit (identifier)) (identifier) (true)))
  (hash_command (explicit (identifier) (identifier))))

========
Coersion
========

#check (2 : Nat)
#check (foo bar : Nat)
#check (foo bar : baz quux)

---

(module
  (hash_command
    (coe
      term: (number)
      type: (identifier)))
  (hash_command
    (coe
      term:
        (apply
          name: (identifier)
          arguments: (identifier))
      type: (identifier)))
  (hash_command
    (coe
      term:
        (apply
          name: (identifier)
          arguments: (identifier))
      type:
        (apply
          name: (identifier)
          arguments: (identifier)))))

=================================
Application Across Multiple Lines
=================================

#eval f
2
3

  4

---

(module
  (hash_command
    (apply
      name: (identifier)
      arguments: (number)
      arguments: (number)
      arguments: (number))))

=================
Structure Literal
=================

#check {x := 12}
#check {x := 12, y := (fun z => z)}

---

(module
  (hash_command
    (structure_literal
      name: (identifier)
      value: (number)))
  (hash_command
    (structure_literal
      name: (identifier)
      value: (number)
      name: (identifier)
      value:
        (lambda
          (parameters
            name: (identifier))
          (identifier)))))

=======================
Typed Structure Literal
=======================

#check {x := 12 : Foo}
#check {x := 12, y := (fun z => z) : Foo Bar}
#check {: Foo}

---

(module
  (hash_command
    (structure_literal
      name: (identifier)
      value: (number)
      type: (identifier)))
  (hash_command
    (structure_literal
      name: (identifier)
      value: (number)
      name: (identifier)
      value:
        (lambda
          (parameters
            name: (identifier))
          (identifier))
      type:
        (apply
          name: (identifier)
          arguments: (identifier))))
  (hash_command
    (structure_literal
      type: (identifier))))

====================
Structure Overriding
====================

#check {foo with x := 12}
#check {foo with x := 12, y := (fun z => z)}
#check {foo with}
#check {bar 37 with x := 12}

---

(module
  (hash_command
    (structure_literal
      extends: (identifier)
      name: (identifier)
      value: (number)))
  (hash_command
    (structure_literal
      extends: (identifier)
      name: (identifier)
      value: (number)
      name: (identifier)
      value:
        (lambda
          (parameters
            name: (identifier))
          (identifier))))
  (hash_command
    (structure_literal
      extends: (identifier)))
  (hash_command
    (structure_literal
      extends:
        (apply
          name: (identifier)
          arguments: (number))
      name: (identifier)
      value: (number))))

===================
Trailing Commas Yay
===================

example : Foo := {x := 12, y := 13,}

---

(module
  (example (identifier)
    (structure_literal (identifier) (number) (identifier) (number))))

=====================
No Trailing Commas Aw
=====================

#check (1, 2, 3,)
#check [1, 2, 3,]
#check #[1, 2, 3,]
example : Foo := ⟨1, 2,⟩
@[foo, bar,] def foo := 12
def foo | 0, => 2 | _, => 3

---

(module
  (hash_command
    (product (number) (number) (number) (MISSING identifier)))
  (hash_command
    (list (number) (number) (number) (MISSING identifier)))
  (hash_command
    (array (number) (number) (number) (MISSING identifier)))
  (example (identifier)
    (inductive_constructor (number) (number) (MISSING identifier)))
  (def (identifier) (identifier) (MISSING identifier) (identifier) (number))
  (def (identifier)
    (pattern (number) (ERROR) (number))
    (pattern (identifier) (ERROR) (number))))
