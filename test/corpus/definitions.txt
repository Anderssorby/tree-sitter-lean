======
Simple
======

def sampleFunction1 x := x*x + 3

def result1 := sampleFunction1 4573

theorem foo : p := sorry

---

(source_file
  (def (identifier)
    (parameter_list (identifier))
    (binary_expression (binary_expression (identifier) (identifier)) (number)))
  (def (identifier)
    (apply (identifier) (number)))
  (theorem (identifier) (identifier) (identifier)))

=========
Annotated
=========

def sampleFunction2 (x : Nat) := 2*x*x - x + 3

---

(source_file
  (def (identifier)
    (parameter_list (annotated (identifier) (identifier)))
    (binary_expression
      (binary_expression
        (binary_expression
          (binary_expression (number) (identifier))
          (identifier))
        (identifier))
      (number))))

==================
Multiple Annotated
==================

def sampleFunction2 (x y : Nat) := x + y

---

(source_file
  (def (identifier)
    (parameter_list (annotated (identifier) (identifier) (identifier)))
    (binary_expression (identifier) (identifier))))

====================
First Class Function
====================

def twice (f : Nat → Nat) (a : Nat) :=
  f (f a)

---

(source_file
  (def (identifier)
    (parameter_list
      (annotated (identifier) (function_annotation (identifier) (identifier)))
      (annotated (identifier) (identifier)))
    (apply (identifier)
      (apply (identifier) (identifier)))))

====================
Function Return Type
====================

def foo : Nat -> Nat := id

---

(source_file
  (def
    name: (identifier)
    return_type: (function_annotation (identifier) (identifier))
    body: (identifier)))

==================================
Multiargument Function Return Type
==================================

def foo : Nat -> Nat -> Nat -> Nat := id

---

(source_file
  (def
    name: (identifier)
    return_type: (function_annotation
                    (identifier) (identifier) (identifier) (identifier))
    body: (identifier)))

==================
Anonymous Function
==================

#check fun x => x + 2

---

(source_file
  (hash_command
    (lambda
      (parameter_list (identifier))
      (binary_expression (identifier) (number)))))

==============================
Anonymous Function Application
==============================

#eval (fun x => x + 2) 10

---

(source_file
  (hash_command
    (apply
      (lambda
        (parameter_list (identifier))
        (binary_expression (identifier) (number)))
      (number))))

============
Conditionals
============

def sampleFunction3 (x : Int) :=
if x > 100 then
  2*x*x - x + 3
else
  2*x*x + x - 37

---

(source_file
(def (identifier)
  (parameter_list (annotated (identifier) (identifier)))
  (conditional (comparison (identifier) (number))
      (binary_expression
        (binary_expression
          (binary_expression
            (binary_expression (number) (identifier))
            (identifier))
          (identifier))
        (number))
      (binary_expression
        (binary_expression
          (binary_expression
            (binary_expression (number) (identifier))
            (identifier))
          (identifier))
        (number)))))


=======
Theorem
=======

theorem twiceAdd2 (a : Nat) : twice (fun x => x + 2) a = a + 4 :=
-- The proof is by reflexivity. Lean "symbolically" reduces both sides of the equality
-- until they are identical.
  rfl

---

(source_file
(theorem (identifier)
  (parameter_list (annotated (identifier) (identifier)))
  (binary_expression
    (apply (identifier)
      (lambda
        (parameter_list (identifier))
        (binary_expression (identifier) (number))) (identifier))
    (binary_expression (identifier) (number)))
    (comment) (comment) (identifier)))

================
Partial Function
================

partial def g x : Nat := g (x + 1)

---

(source_file
  (def (identifier)
    (parameter_list (identifier))
    (identifier)
    (apply (identifier) (binary_expression (identifier) (number)))))

=========
Structure
=========

structure Point (α : Type u) where
  w x : α
  y : α

---

(source_file
  (structure_definition
    name: (identifier)
    parameters: (parameter_list
        (annotated (identifier)
            (apply
                name: (identifier)
                arguments: (identifier))))
    fields:
        (structure_field
            name: (identifier)
            name: (identifier)
            type: (identifier))
    fields:
        (structure_field
            name: (identifier)
            type: (identifier))))
