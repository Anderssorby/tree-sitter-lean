======
Simple
======

def sampleFunction1 x := x*x + 3

def result1 := sampleFunction1 4573

theorem foo : p := sorry

---

(module
  (def (identifier)
    (parameters (identifier))
    (binary_expression (binary_expression (identifier) (identifier)) (number)))
  (def (identifier)
    (apply (identifier) (number)))
  (theorem (identifier) (identifier) (sorry)))

=========
Annotated
=========

def sampleFunction2 (x : Nat) := 2*x*x - x + 3

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression
        (binary_expression
          (binary_expression
          (binary_expression (number) (identifier))
            (identifier))
            (identifier))
        (number))))

==================
Multiple Annotated
==================

def sampleFunction2 (x y : Nat) := x + y

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression (identifier) (identifier))))

==================
Implicit Arguments
==================

def foo {a} {b c : Nat} v w (x y) (z : Nat) := a + b + v + w + x + y

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        (implicit_parameter
          name: (identifier))
        (implicit_parameter
          name: (identifier)
          name: (identifier)
          type: (identifier))
        name: (identifier)
        name: (identifier)
        name: (identifier)
        name: (identifier)
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression
        (binary_expression
          (binary_expression
            (binary_expression
              (binary_expression
                (identifier)
                (identifier))
              (identifier))
            (identifier))
          (identifier))
        (identifier))))

============================
Typeclass Resolved Arguments
============================

def foo [Bar x] [y : Baz] : x := 1

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        (typeclass_resolved_parameter
          type:
            (apply
              name: (identifier)
              arguments: (identifier)))
        (typeclass_resolved_parameter
          name: (identifier)
          type: (identifier)))
    return_type: (identifier)
    body: (number)))

====================
First Class Function
====================

def twice (f : Nat → Nat) (a : Nat) :=
  f (f a)

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (function_type (identifier) (identifier))
        name: (identifier)
        type: (identifier))
    body:
      (apply
        name: (identifier)
        arguments:
          (apply
            name: (identifier)
            arguments: (identifier)))))

====================
Function Return Type
====================

def foo : Nat -> Nat := id

---

(module
  (def
    name: (identifier)
    return_type: (function_type (identifier) (identifier))
    body: (identifier)))

==================================
Multiargument Function Return Type
==================================

def foo : Nat -> Nat -> Nat -> Nat := id

---

(module
  (def
    name: (identifier)
    return_type:
      (function_type
        (identifier) (identifier) (identifier) (identifier))
    body: (identifier)))

==========
Attributes
==========

@[reducible] def f := 12

---

(module
  (def
    attributes: (identifier)
    name: (identifier)
    body: (number)))

===================
Multiple Attributes
===================

@[reducible, inline] def f := 12

---

(module
  (def
    attributes: (identifier)
    attributes: (identifier)
    name: (identifier)
    body: (number)))

=================
Missing Attribute
=================

@[] def f := 12

---

(module (ERROR) (def name: (identifier) body: (number)))

======================
Partial With Attribute
======================

@[reducible] partial def f := 12

---

(module
  (def
    attributes: (identifier)
    name: (identifier)
    body: (number)))

============
Conditionals
============

def sampleFunction3 (x : Int) :=
if x > 100 then
  2*x*x - x + 3
else
  2*x*x + x - 37

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    body:
      (conditional (comparison (identifier) (number))
          (binary_expression
            (binary_expression
              (binary_expression
                (binary_expression (number) (identifier))
                (identifier))
              (identifier))
            (number))
          (binary_expression
            (binary_expression
              (binary_expression
                (binary_expression (number) (identifier))
                (identifier))
              (identifier))
            (number)))))

=======
Theorem
=======

theorem twiceAdd2 (a : Nat) : twice (fun x => x + 2) a = a + 4 :=
-- The proof is by reflexivity. Lean "symbolically" reduces both sides of the equality
-- until they are identical.
  rfl

---

(module
  (theorem
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    type:
      (binary_expression
        (apply
          name: (identifier)
          arguments:
            (lambda
              (parameters
                name: (identifier))
              (binary_expression (identifier) (number)))
          arguments:
            (identifier))
        (binary_expression (identifier) (number)))
      (comment) (comment)
    body:
      (identifier)))

============================
Theorem With Expression Body
============================

theorem bar : 2 * 3 = 3 * 2 := Nat.mul_comm 2 3

---

(module
  (theorem
    name: (identifier)
    type:
      (binary_expression
        (binary_expression (number) (number))
        (binary_expression (number) (number)))
    body:
      (apply
        name:
          (field_of
            term: (identifier)
            name: (identifier))
        arguments: (number)
        arguments: (number))))

========================
Theorem With Tactic Body
========================

theorem foo {m n : Nat} : 2 * m + 2 * n = 2 * (n + m) := by
  rewrite Nat.add_comm
  exact (Nat.left_distrib 2 n m).symm

---

(module
  (theorem
    name: (identifier)
    parameters:
      (parameters
        (implicit_parameter
          name: (identifier)
          name: (identifier)
          type: (identifier)))
    type:
      (binary_expression
        (binary_expression
          (binary_expression (number) (identifier))
          (binary_expression (number) (identifier)))
        (binary_expression
          (number)
          (binary_expression (identifier) (identifier))))
    body:
      (tactics
        (rewrite
          (field_of
            term: (identifier)
            name: (identifier)))
        (term
          (field_of
            term:
              (apply
                name:
                  (field_of
                    term: (identifier)
                    name: (identifier))
                arguments: (number)
                arguments: (identifier)
                arguments: (identifier))
            name: (identifier))))))

=================
Tactic Expression
=================

variable {m n : Nat}
#check (by
  rewrite Nat.add_comm
  exact (Nat.left_distrib 2 n m).symm : 2 * m + 2 * n = 2 * (n + m))

---

(module
  (variable_declaration
    (implicit_parameter
      name: (identifier)
      name: (identifier)
      type: (identifier)))
  (hash_command
    (coe
      term:
        (tactics
          (rewrite
            (field_of
              term: (identifier)
              name: (identifier)))
          (term
            (field_of
              term:
                (apply
                  name:
                    (field_of
                      term: (identifier)
                      name: (identifier))
                  arguments: (number)
                  arguments: (identifier)
                  arguments: (identifier))
              name: (identifier))))
        type:
          (binary_expression
            (binary_expression
              (binary_expression (number) (identifier))
              (binary_expression (number) (identifier)))
            (binary_expression
              (number)
              (binary_expression (identifier) (identifier)))))))

================
Partial Function
================

partial def g x : Nat := g (x + 1)

---

(module
  (def (identifier)
    (parameters (identifier))
    (identifier)
    (apply (identifier) (binary_expression (identifier) (number)))))

=========
Structure
=========

structure Point (α : Type u) where
  w : String := "foo"
  x : α
  y : α
  z := 0

---

(module
  (structure_definition
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type:
          (apply
            name: (identifier)
            arguments: (identifier)))
    fields:
      (field
        name: (identifier)
        type: (identifier)
        default: (string))
    fields:
      (field
        name: (identifier)
        type: (identifier))
    fields:
      (field
        name: (identifier)
        type: (identifier))
    fields:
      (field
        name: (identifier)
        default: (number))))

=====
Class
=====

class Add (a : Type) where
  foo : String := "foo"
  add : a -> a -> a
  bar := 0

---

(module
  (class
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    fields:
      (field
        name: (identifier)
        type: (identifier)
        default: (string))
    fields:
      (field
        name: (identifier)
        type: (function_type (identifier) (identifier) (identifier)))
    fields:
      (field
        name: (identifier)
        default: (number))))

========
Instance
========

instance : ToString Foo where
  toString (d : Foo) : String := "Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters
            name: (identifier)
            type: (identifier))
        return_type: (identifier)
        body: (string))))

==============
Named Instance
==============

instance toStringFoo : ToString Foo where
  toString (d : Foo) : String := "Foo"

---

(module
  (instance
    name: (identifier)
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters
            name: (identifier)
            type: (identifier))
        return_type: (identifier)
        body: (string))))

========================
Instance With Parameters
========================

instance {f : Foo} (g : Bar 3) : Quux where
  foo := f

---

(module
  (instance
    parameters:
      (implicit_parameter
        name: (identifier)
        type: (identifier))
      name: (identifier)
      type:
        (apply
          name: (identifier)
          arguments: (number))
    class: (identifier)
    fields:
      (instance_field
        name: (identifier)
        body: (identifier))))

================
Chained Instance
================

instance [Inhabited b] : Inhabited (a -> b) where
  default := fun _ => arbitrary

---

(module
  (instance
    parameters:
      (typeclass_resolved_parameter
        type:
          (apply
            name: (identifier)
            arguments: (identifier)))
    class:
      (apply
        name: (identifier)
        arguments: (function_type (identifier) (identifier)))
    fields:
      (instance_field
        name: (identifier)
        body:
          (lambda
            (parameters
              name: (identifier))
            (identifier)))))

===================================
Instance With Inductive Constructor
===================================

instance : Inhabited Nat := ⟨0⟩

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    body: (inductive_constructor (number))))

========================================
Instance Field With Function Return Type
========================================

instance : ToString Foo where
  toString : Foo → String := λ f => s!"Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        return_type: (function_type (identifier) (identifier))
        body:
          (lambda
            (parameters name: (identifier))
            (interpolated_string)))))

==================================
Instance Field Without Return Type
==================================

instance : ToString Foo where
  toString d := "Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters name: (identifier))
        body: (string))))

=======
Example
=======

example : (fun x => x * 2) 4 < 3 = false := rfl

---

(module
  (example
    (binary_expression
      (comparison
        (apply
          (lambda (parameters (identifier))
            (binary_expression (identifier) (number))) (number))
        (number))
      (false))
    (identifier)))

=======================
Example With Parameters
=======================

example {G : Type} [Add G] (g : G) : g + g = g + g := rfl

---

(module
  (example
    parameters:
      (parameters
        (implicit_parameter
          name: (identifier)
          type: (identifier))
        (typeclass_resolved_parameter
          type:
            (apply
              name: (identifier)
              arguments: (identifier)))
        name: (identifier)
        type: (identifier))
    type:
      (binary_expression
        (binary_expression (identifier) (identifier))
        (binary_expression (identifier) (identifier)))
    body:
      (identifier)))

============================
Protected / Private / Unsafe
============================

protected unsafe def foo := 12

private structure Foo where x : Nat

protected class Bar where x : Nat

protected instance : Quux where x := 2

private theorem bar : 2 = 2 := rfl

protected example : 2 = 2 := rfl

---

(module
  (def (identifier) (number))
  (structure_definition (identifier) (field (identifier) (identifier)))
  (class (identifier) (field (identifier) (identifier)))
  (instance (identifier) (instance_field (identifier) (number)))
  (theorem (identifier) (binary_expression (number) (number)) (identifier))
  (example (binary_expression (number) (number)) (identifier)))

==============
Inductive Type
==============

inductive FooBar where
  | foo : FooBar
  | bar.baz : FooBar
  | spam : Nat → FooBar
  | quux {T: Type} [Add T] (x y : Nat) : Nat → FooBar

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier)
        type: (identifier))
    constructors:
      (constructor
        name: (identifier)
        name: (identifier)
        type: (identifier))
    constructors:
      (constructor
        name: (identifier)
        type:
          (function_type (identifier) (identifier)))
    constructors:
      (constructor
        name: (identifier)
        parameters:
          (implicit_parameter
            name: (identifier)
            type: (identifier))
        parameters:
          (typeclass_resolved_parameter
            type:
              (apply
                name: (identifier)
                arguments: (identifier)))
          name: (identifier)
          name: (identifier)
          type: (identifier)
        type:
          (function_type (identifier) (identifier)))))

=======================
Inductive Type One Line
=======================

inductive Bit | bit0 | bit1

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))
    constructors:
      (constructor
        name: (identifier))))

================================
Inductive Type Superfluous Where
================================

inductive Bit where | bit0 | bit1

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))
    constructors:
      (constructor
        name: (identifier))))

=================
Inline Namespaced
=================

def foo.bar.baz := 12

structure Foo.Bar.Baz where
  x : Nat

class Foo.Bar.Baz.Quux where
  x : Nat

instance Spam.Eggs : Foo.Bar.Baz.Quux where
  x := 3

theorem Foo.Bar.Baz.Quux.Cheese : 2 = 2 := rfl

inductive A.B | C

---

(module
  (def
    name: (identifier)
    name: (identifier)
    name: (identifier)
    body: (number))
  (structure_definition
    name: (identifier)
    name: (identifier)
    name: (identifier)
    fields:
      (field
        name: (identifier)
        type: (identifier)))
  (class
    name: (identifier)
    name: (identifier)
    name: (identifier)
    name: (identifier)
    fields:
      (field
        name: (identifier)
        type: (identifier)))
  (instance
    name: (identifier)
    name: (identifier)
    class:
      (field_of
        term:
          (field_of
            term:
              (field_of
                term: (identifier)
                name: (identifier))
            name: (identifier))
        name: (identifier))
    fields:
      (instance_field
        name: (identifier)
        body: (number)))
  (theorem
    name: (identifier)
    name: (identifier)
    name: (identifier)
    name: (identifier)
    name: (identifier)
    type: (binary_expression (number) (number))
    body: (identifier))
  (inductive_type
    name: (identifier)
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))))

===
Let
===

def foo :=
  let foo := 12
  foo

---

(module
  (def
    name: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            body: (number))
        arguments: (identifier))))

=============
Let Annotated
=============

def foo :=
  let foo : Nat := 12
  foo

---

(module
  (def
    name: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            type: (identifier)
            body: (number))
        arguments: (identifier))))

============
Let Function
============

def foo : Nat :=
  let val (x y : Nat) := x + y
  return val 2 3

---

(module
  (def
    name: (identifier)
    return_type: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            name: (identifier)
            name: (identifier)
            type: (identifier)
            body: (binary_expression (identifier) (identifier)))
        arguments:
          (identifier)
        arguments:
          (identifier)
        arguments:
          (number)
        arguments:
          (number))))

==========
No Let Mut
==========

def foo :=
  let mut foo := 12
  foo

---

(module
  (def
    name: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            (ERROR (identifier))
            body: (number)) arguments: (identifier))))

============
No Let Arrow
============

def foo :=
  let foo <- 12
  foo

---

(module
  (def
    name: (identifier)
    (ERROR (identifier))
    body:
      (apply name: (number) arguments: (identifier))))
