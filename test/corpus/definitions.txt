======
Simple
======

def sampleFunction1 x := x*x + 3

def result1 := sampleFunction1 4573

theorem foo : p := sorry

---

(source_file
  (function_definition (identifier)
    (parameter_list (identifier))
    (binary_expression (binary_expression (identifier) (identifier)) (number)))
  (function_definition (identifier)
    (function_application (identifier) (number)))
  (theorem_definition (identifier) (identifier) (identifier)))

=========
Annotated
=========

def sampleFunction2 (x : Nat) := 2*x*x - x + 3

---

(source_file
  (function_definition (identifier)
    (parameter_list (annotated (identifier) (identifier)))
    (binary_expression
      (binary_expression
        (binary_expression
          (binary_expression (number) (identifier))
          (identifier))
        (identifier))
      (number))))

====================
First Class Function
====================

def twice (f : Nat â†’ Nat) (a : Nat) :=
  f (f a)

---

(source_file
  (function_definition (identifier)
    (parameter_list
      (annotated (identifier) (function_annotation (identifier) (identifier)))
      (annotated (identifier) (identifier)))
    (function_application (identifier)
      (function_application (identifier) (identifier)))))

==================
Anonymous Function
==================

#check fun x => x + 2

---

(source_file
  (hash_command
    (lambda
      (parameter_list (identifier))
      (binary_expression (identifier) (number)))))

==============================
Anonymous Function Application
==============================

#eval (fun x => x + 2) 10

---

(source_file
  (hash_command
    (function_application
      (lambda
        (parameter_list (identifier))
        (binary_expression (identifier) (number)))
      (number))))

============
Conditionals
============

def sampleFunction3 (x : Int) :=
if x > 100 then
  2*x*x - x + 3
else
  2*x*x + x - 37

---

(source_file
(function_definition (identifier)
  (parameter_list (annotated (identifier) (identifier)))
  (conditional (comparison (identifier) (number))
      (binary_expression
        (binary_expression
          (binary_expression
            (binary_expression (number) (identifier))
            (identifier))
          (identifier))
        (number))
      (binary_expression
        (binary_expression
          (binary_expression
            (binary_expression (number) (identifier))
            (identifier))
          (identifier))
        (number)))))


=======
Theorem
=======

theorem twiceAdd2 (a : Nat) : twice (fun x => x + 2) a = a + 4 :=
-- The proof is by reflexivity. Lean "symbolically" reduces both sides of the equality
-- until they are identical.
  rfl

---

(source_file
(theorem_definition (identifier)
  (parameter_list (annotated (identifier) (identifier)))
  (binary_expression
    (function_application (identifier)
      (lambda
        (parameter_list (identifier))
        (binary_expression (identifier) (number))) (identifier))
    (binary_expression (identifier) (number)))
    (comment) (comment) (identifier)))
