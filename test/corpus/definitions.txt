======
Simple
======

def sampleFunction1 x := x*x + 3

def result1 := sampleFunction1 4573

theorem foo : p := sorry

---

(module
  (def (identifier)
    (parameters (identifier))
    (binary_expression (binary_expression (identifier) (identifier)) (number)))
  (def (identifier)
    (apply (identifier) (number)))
  (theorem (identifier) (identifier) (sorry)))

=========
Annotated
=========

def sampleFunction2 (x : Nat) := 2*x*x - x + 3

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression
        (binary_expression
          (binary_expression
          (binary_expression (number) (identifier))
            (identifier))
            (identifier))
        (number))))

==================
Multiple Annotated
==================

def sampleFunction2 (x y : Nat) := x + y

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression (identifier) (identifier))))

==================
Implicit Arguments
==================

def foo {a} {b c : Nat} v w (x y) (z : Nat) := a + b + v + w + x + y

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        (implicit_parameter
          name: (identifier))
        (implicit_parameter
          name: (identifier)
          name: (identifier)
          type: (identifier))
        name: (identifier)
        name: (identifier)
        name: (identifier)
        name: (identifier)
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression
        (binary_expression
          (binary_expression
            (binary_expression
              (binary_expression
                (identifier)
                (identifier))
              (identifier))
            (identifier))
          (identifier))
        (identifier))))

============================
Typeclass Resolved Arguments
============================

def foo [Bar x] [y : Baz] : x := 1

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        (typeclass_resolved_parameter
          type:
            (apply
              name: (identifier)
              arguments: (identifier)))
        (typeclass_resolved_parameter
          name: (identifier)
          type: (identifier)))
    return_type: (identifier)
    body: (number)))

====================
First Class Function
====================

def twice (f : Nat → Nat) (a : Nat) :=
  f (f a)

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (function_type (identifier) (identifier))
        name: (identifier)
        type: (identifier))
    body:
      (apply
        name: (identifier)
        arguments:
          (apply
            name: (identifier)
            arguments: (identifier)))))

====================
Function Return Type
====================

def foo : Nat -> Nat := id

---

(module
  (def
    name: (identifier)
    return_type: (function_type (identifier) (identifier))
    body: (identifier)))

==================================
Multiargument Function Return Type
==================================

def foo : Nat -> Nat -> Nat -> Nat := id

---

(module
  (def
    name: (identifier)
    return_type:
      (function_type
        (identifier) (identifier) (identifier) (identifier))
    body: (identifier)))

============
Conditionals
============

def sampleFunction3 (x : Int) :=
if x > 100 then
  2*x*x - x + 3
else
  2*x*x + x - 37

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    body:
      (conditional (comparison (identifier) (number))
          (binary_expression
            (binary_expression
              (binary_expression
                (binary_expression (number) (identifier))
                (identifier))
              (identifier))
            (number))
          (binary_expression
            (binary_expression
              (binary_expression
                (binary_expression (number) (identifier))
                (identifier))
              (identifier))
            (number)))))

=======
Theorem
=======

theorem twiceAdd2 (a : Nat) : twice (fun x => x + 2) a = a + 4 :=
-- The proof is by reflexivity. Lean "symbolically" reduces both sides of the equality
-- until they are identical.
  rfl

---

(module
  (theorem
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    type:
      (binary_expression
        (apply
          name: (identifier)
          arguments:
            (lambda
              (parameters
                name: (identifier))
              (binary_expression (identifier) (number)))
          arguments:
            (identifier))
        (binary_expression (identifier) (number)))
      (comment) (comment)
    body:
      (identifier)))

============================
Theorem With Expression Body
============================

theorem bar : 2 * 3 = 3 * 2 := Nat.mul_comm 2 3

---

(module
  (theorem
    name: (identifier)
    type:
      (binary_expression
        (binary_expression (number) (number))
        (binary_expression (number) (number)))
    body:
      (apply
        name:
          (field_of
            term: (identifier)
            name: (identifier))
        arguments: (number)
        arguments: (number))))

=========
Structure
=========

structure Point (α : Type u) where
  w : String := "foo"
  x : α
  y : α
  z := 0

---

(module
  (structure_definition
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type:
          (apply
            name: (identifier)
            arguments: (identifier)))
    fields:
      (field
        name: (identifier)
        type: (identifier)
        default: (string))
    fields:
      (field
        name: (identifier)
        type: (identifier))
    fields:
      (field
        name: (identifier)
        type: (identifier))
    fields:
      (field
        name: (identifier)
        default: (number))))

=====
Class
=====

class Add (a : Type) where
  foo : String := "foo"
  add : a -> a -> a
  bar := 0

---

(module
  (class
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    fields:
      (field
        name: (identifier)
        type: (identifier)
        default: (string))
    fields:
      (field
        name: (identifier)
        type: (function_type (identifier) (identifier) (identifier)))
    fields:
      (field
        name: (identifier)
        default: (number))))

========
Instance
========

instance : ToString Foo where
  toString (d : Foo) : String := "Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters
            name: (identifier)
            type: (identifier))
        return_type: (identifier)
        body: (string))))

==============
Named Instance
==============

instance toStringFoo : ToString Foo where
  toString (d : Foo) : String := "Foo"

---

(module
  (instance
    name: (identifier)
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters
            name: (identifier)
            type: (identifier))
        return_type: (identifier)
        body: (string))))

========================
Instance With Parameters
========================

instance {f : Foo} (g : Bar 3) : Quux where
  foo := f

---

(module
  (instance
    parameters:
      (implicit_parameter
        name: (identifier)
        type: (identifier))
      name: (identifier)
      type:
        (apply
          name: (identifier)
          arguments: (number))
    class: (identifier)
    fields:
      (instance_field
        name: (identifier)
        body: (identifier))))

================
Chained Instance
================

instance [Inhabited b] : Inhabited (a -> b) where
  default := fun _ => arbitrary

---

(module
  (instance
    parameters:
      (typeclass_resolved_parameter
        type:
          (apply
            name: (identifier)
            arguments: (identifier)))
    class:
      (apply
        name: (identifier)
        arguments: (function_type (identifier) (identifier)))
    fields:
      (instance_field
        name: (identifier)
        body:
          (lambda
            (parameters
              name: (identifier))
            (identifier)))))

===================================
Instance With Inductive Constructor
===================================

instance : Inhabited Nat := ⟨0⟩

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    body: (inductive_constructor (number))))

==============================
Instance With Field Definition
==============================

instance : Add Foo := Foo.add

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    body:
      (field_of
        term: (identifier)
        name: (identifier))))

========================================
Instance Field With Function Return Type
========================================

instance : ToString Foo where
  toString : Foo → String := λ f => s!"Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        return_type: (function_type (identifier) (identifier))
        body:
          (lambda
            (parameters name: (identifier))
            (interpolated_string)))))

==================================
Instance Field Without Return Type
==================================

instance : ToString Foo where
  toString d := "Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters name: (identifier))
        body: (string))))

=======
Example
=======

example : (fun x => x * 2) 4 < 3 = false := rfl

---

(module
  (example
    (binary_expression
      (comparison
        (apply
          (lambda (parameters (identifier))
            (binary_expression (identifier) (number))) (number))
        (number))
      (false))
    (identifier)))

=======================
Example With Parameters
=======================

example {G : Type} [Add G] (g : G) : g + g = g + g := rfl

---

(module
  (example
    parameters:
      (parameters
        (implicit_parameter
          name: (identifier)
          type: (identifier))
        (typeclass_resolved_parameter
          type:
            (apply
              name: (identifier)
              arguments: (identifier)))
        name: (identifier)
        type: (identifier))
    type:
      (binary_expression
        (binary_expression (identifier) (identifier))
        (binary_expression (identifier) (identifier)))
    body:
      (identifier)))

======================================================
Noncomputable / Partial / Protected / Private / Unsafe
======================================================

partial def foo := 12

partial def g x : Nat := g (x + 1)

noncomputable def foo := 12

protected unsafe def foo := 12

unsafe inductive Foo | foo

private structure Foo where x : Nat

protected class Bar where x : Nat

protected instance : Quux where x := 2

noncomputable instance : Foo where x := 2

private theorem bar : 2 = 2 := rfl

protected example : 2 = 2 := rfl

noncomputable example : 2 = 2 := rfl

protected constant FooBar : Nat

noncomputable constant FooBar : Nat

---

(module
  (def (identifier) (number))
  (def (identifier)
    (parameters (identifier))
    (identifier)
    (apply (identifier) (binary_expression (identifier) (number))))
  (def (identifier) (number))
  (def (identifier) (number))
  (inductive_type (identifier) (constructor (identifier)))
  (structure_definition (identifier) (field (identifier) (identifier)))
  (class (identifier) (field (identifier) (identifier)))
  (instance (identifier) (instance_field (identifier) (number)))
  (instance (identifier) (instance_field (identifier) (number)))
  (theorem (identifier) (binary_expression (number) (number)) (identifier))
  (example (binary_expression (number) (number)) (identifier))
  (example (binary_expression (number) (number)) (identifier))
  (constant (identifier) (identifier))
  (constant (identifier) (identifier)))

===============================================================
No Partial / Noncomputable / Attributes / Private for Inductive
===============================================================

partial inductive T1 : Type -- invalid use of partial
noncomputable inductive T1 : Type -- invalid use of noncomputable
@[inline] inductive T1 : Type -- invalid use of attributes

private inductive T1 : Type
| private mk : T1 -- invalid private constructor in private inductive type

---

(module
  (inductive_type (identifier) (ERROR) (parameters (identifier))) (comment)
  (inductive_type (identifier) (ERROR) (parameters (identifier))) (comment)
  (ERROR (identifier)
    (ERROR (comment))
      (ERROR) (comment)))

==========
Attributes
==========

@[reducible] def f := 12

@[inline] instance : Foo := ⟨7⟩

@[simp] theorem twotwo : 2 = 2 := rfl

@[inline] constant FooBar : Nat

---

(module
  (def
    attributes: (identifier)
    name: (identifier)
    body: (number))
  (instance
    attributes: (identifier)
    class: (identifier)
    body: (inductive_constructor (number)))
  (theorem
    attributes: (identifier)
    name: (identifier)
    type: (binary_expression (number) (number))
    body: (identifier))
  (constant
    attributes: (identifier)
    name: (identifier)
    type: (identifier)))

===================
Multiple Attributes
===================

@[reducible, inline] def f := 12

---

(module
  (def
    attributes: (identifier)
    attributes: (identifier)
    name: (identifier)
    body: (number)))

=================
Missing Attribute
=================

@[] def f := 12

---

(module
  (def
    attributes: (identifier (MISSING _identifier))
    name: (identifier)
    body: (number)))

==============================
Explicit Attribute Declaration
==============================

attribute [reducible] f
attribute [simp, inline] Foo

---

(module
  (attribute
    added: (identifier)
    term: (identifier))
  (attribute
    added: (identifier)
    added: (identifier)
    term: (identifier)))

==========================
Explicit Attribute Removal
==========================

attribute [-reducible] f
attribute [simp, -inline, -reducible] Foo

---

(module
  (attribute
    removed: (identifier)
    term: (identifier))
  (attribute
    added: (identifier)
    removed: (identifier)
    removed: (identifier)
    term: (identifier)))

====================================
Empty Explicit Attribute Declaration
====================================

attribute [] f

---

(module (attribute (identifier (MISSING _identifier)) (identifier)))

======================
Partial With Attribute
======================

@[reducible] partial def f := 12

---

(module
  (def
    attributes: (identifier)
    name: (identifier)
    body: (number)))

==============
Inductive Type
==============

inductive FooBar where
  | foo : FooBar
  | bar.baz : FooBar
  | spam : Nat → FooBar
  | quux {T: Type} [Add T] (x y : Nat) : Nat → FooBar

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier)
        type: (identifier))
    constructors:
      (constructor
        name: (identifier)
        name: (identifier)
        type: (identifier))
    constructors:
      (constructor
        name: (identifier)
        type:
          (function_type (identifier) (identifier)))
    constructors:
      (constructor
        name: (identifier)
        parameters:
          (implicit_parameter
            name: (identifier)
            type: (identifier))
        parameters:
          (typeclass_resolved_parameter
            type:
              (apply
                name: (identifier)
                arguments: (identifier)))
          name: (identifier)
          name: (identifier)
          type: (identifier)
        type:
          (function_type (identifier) (identifier)))))

==============================
Inductive Type No Constructors
==============================

inductive Foo

---

(module
  (inductive_type
    name: (identifier)))

==============================
Inductive Type With Parameters
==============================

inductive Foo (F : Type) | x (foo : F)

---

(module
  (inductive_type
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    constructors:
      (constructor
        name: (identifier)
        name: (identifier)
        type: (identifier))))

=======================
Inductive Type One Line
=======================

inductive Bit | bit0 | bit1

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))
    constructors:
      (constructor
        name: (identifier))))

================================
Inductive Type Superfluous Where
================================

inductive Bit where | bit0 | bit1

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))
    constructors:
      (constructor
        name: (identifier))))

=================
Inline Namespaced
=================

def foo.bar.baz := 12

structure Foo.Bar.Baz where
  x : Nat

class Foo.Bar.Baz.Quux where
  x : Nat

instance Spam.Eggs : Foo.Bar.Baz.Quux where
  x := 3

theorem Foo.Bar.Baz.Quux.Cheese : 2 = 2 := rfl

inductive A.B | C

---

(module
  (def
    name: (identifier)
    name: (identifier)
    name: (identifier)
    body: (number))
  (structure_definition
    name: (identifier)
    name: (identifier)
    name: (identifier)
    fields:
      (field
        name: (identifier)
        type: (identifier)))
  (class
    name: (identifier)
    name: (identifier)
    name: (identifier)
    name: (identifier)
    fields:
      (field
        name: (identifier)
        type: (identifier)))
  (instance
    name: (identifier)
    name: (identifier)
    class:
      (field_of
        term:
          (field_of
            term:
              (field_of
                term: (identifier)
                name: (identifier))
            name: (identifier))
        name: (identifier))
    fields:
      (instance_field
        name: (identifier)
        body: (number)))
  (theorem
    name: (identifier)
    name: (identifier)
    name: (identifier)
    name: (identifier)
    name: (identifier)
    type: (binary_expression (number) (number))
    body: (identifier))
  (inductive_type
    name: (identifier)
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))))

===
Let
===

def foo :=
  let foo := 12
  foo

---

(module
  (def
    name: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            body: (number))
        arguments: (identifier))))

=============
Let Annotated
=============

def foo :=
  let foo : Nat := 12
  foo

---

(module
  (def
    name: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            type: (identifier)
            body: (number))
        arguments: (identifier))))

============
Let Function
============

def foo : Nat :=
  let val (x y : Nat) := x + y
  return val 2 3

---

(module
  (def
    name: (identifier)
    return_type: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            name: (identifier)
            name: (identifier)
            type: (identifier)
            body: (binary_expression (identifier) (identifier)))
        arguments:
          (identifier)
        arguments:
          (identifier)
        arguments:
          (number)
        arguments:
          (number))))

==============
Let Semicolons
==============

def foo :=
let foo := 12
let bar := 13
let baz := 14
foo + bar + baz

def bar :=
let foo := 12;
let bar := 13;
let baz := 14;
foo + bar + baz

def baz :=
let foo := 12; let bar := 13; let baz := 14;
foo + bar + baz

def quux :=
  let foo := 12
  let bar := 13
  let baz := 14
  foo + bar + baz

---

(module
  (def (identifier)
    (apply
      (let (identifier) (number))
      (let (identifier) (number))
      (let (identifier) (number))
      (binary_expression (binary_expression (identifier) (identifier))
      (identifier))))
  (def (identifier)
    (apply
      (let (identifier) (number))
      (let (identifier) (number))
      (let (identifier) (number))
      (binary_expression (binary_expression (identifier) (identifier))
      (identifier))))
  (def (identifier)
    (apply
      (let (identifier) (number))
      (let (identifier) (number))
      (let (identifier) (number))
      (binary_expression (binary_expression (identifier) (identifier))
      (identifier))))
  (def (identifier)
    (apply
      (let (identifier) (number))
      (let (identifier) (number))
      (let (identifier) (number))
      (binary_expression (binary_expression (identifier) (identifier))
      (identifier)))))

==========
No Let Mut
==========

def foo :=
  let mut foo := 12
  foo

---

(module
  (def
    name: (identifier)
    body:
      (apply
        name:
          (let
            name: (identifier)
            (ERROR)
            body: (number)) arguments: (identifier))))

============
No Let Arrow
============

def foo :=
  let foo <- 12
  foo

---

(module
  (def
    name: (identifier)
    (ERROR (identifier))
    body:
      (apply name: (number) arguments: (identifier))))
