======
Simple
======

def sampleFunction1 x := x*x + 3

def result1 := sampleFunction1 4573

theorem foo : p := sorry

---

(module
  (def (identifier)
    (parameters (identifier))
    (binary_expression (binary_expression (identifier) (identifier)) (number)))
  (def (identifier)
    (apply (identifier) (number)))
  (theorem (identifier) (identifier) (identifier)))

=========
Annotated
=========

def sampleFunction2 (x : Nat) := 2*x*x - x + 3

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression
        (binary_expression
          (binary_expression
          (binary_expression (number) (identifier))
            (identifier))
            (identifier))
        (number))))

==================
Multiple Annotated
==================

def sampleFunction2 (x y : Nat) := x + y

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression (identifier) (identifier))))

==================
Implicit Arguments
==================

def foo {a} {b c : Nat} v w (x y) (z : Nat) := a + b + v + w + x + y

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        (implicit_parameter
          name: (identifier))
        (implicit_parameter
          name: (identifier)
          name: (identifier)
          type: (identifier))
        name: (identifier)
        name: (identifier)
        name: (identifier)
        name: (identifier)
        name: (identifier)
        type: (identifier))
    body:
      (binary_expression
        (binary_expression
          (binary_expression
            (binary_expression
              (binary_expression
                (identifier)
                (identifier))
              (identifier))
            (identifier))
          (identifier))
        (identifier))))

====================
First Class Function
====================

def twice (f : Nat → Nat) (a : Nat) :=
  f (f a)

---

(module
  (def
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type: (function_annotation (identifier) (identifier))
        name: (identifier)
        type: (identifier))
    body:
      (apply
        name: (identifier)
        arguments:
          (apply
            name: (identifier)
            arguments: (identifier)))))

====================
Function Return Type
====================

def foo : Nat -> Nat := id

---

(module
  (def
    name: (identifier)
    return_type: (function_annotation (identifier) (identifier))
    body: (identifier)))

==================================
Multiargument Function Return Type
==================================

def foo : Nat -> Nat -> Nat -> Nat := id

---

(module
  (def
    name: (identifier)
    return_type: (function_annotation
                    (identifier) (identifier) (identifier) (identifier))
    body: (identifier)))

==========
Attributes
==========

@[reducible] def f := 12

---

(module
  (def
    attributes: (identifier)
    name: (identifier)
    body: (number)))

===================
Multiple Attributes
===================

@[reducible, inline] def f := 12

---

(module
  (def
    attributes: (identifier)
    attributes: (identifier)
    name: (identifier)
    body: (number)))

=================
Missing Attribute
=================

@[] def f := 12

---

(module (ERROR) (def name: (identifier) body: (number)))

======================
Partial With Attribute
======================

@[reducible] partial def f := 12

---

(module
  (def
    attributes: (identifier)
    name: (identifier)
    body: (number)))

============
Conditionals
============

def sampleFunction3 (x : Int) :=
if x > 100 then
  2*x*x - x + 3
else
  2*x*x + x - 37

---

(module
(def
  name: (identifier)
  parameters:
    (parameters
      name: (identifier)
      type: (identifier))
  body:
    (conditional (comparison (identifier) (number))
        (binary_expression
          (binary_expression
            (binary_expression
              (binary_expression (number) (identifier))
              (identifier))
            (identifier))
          (number))
        (binary_expression
          (binary_expression
            (binary_expression
              (binary_expression (number) (identifier))
              (identifier))
            (identifier))
          (number)))))

=======
Theorem
=======

theorem twiceAdd2 (a : Nat) : twice (fun x => x + 2) a = a + 4 :=
-- The proof is by reflexivity. Lean "symbolically" reduces both sides of the equality
-- until they are identical.
  rfl

---

(module
(theorem
  name: (identifier)
  parameters:
    (parameters
      name: (identifier)
      type: (identifier))
    (binary_expression
      (apply
        name: (identifier)
        arguments:
          (lambda
            (parameters
              name: (identifier))
            (binary_expression (identifier) (number)))
        arguments:
          (identifier))
      (binary_expression (identifier) (number)))
    (comment) (comment)
  body:
    (identifier)))

================
Partial Function
================

partial def g x : Nat := g (x + 1)

---

(module
  (def (identifier)
    (parameters (identifier))
    (identifier)
    (apply (identifier) (binary_expression (identifier) (number)))))

=========
Structure
=========

structure Point (α : Type u) where
  x : α
  y : α

---

(module
  (structure_definition
    name: (identifier)
    parameters:
      (parameters
        name: (identifier)
        type:
          (apply
            name: (identifier)
            arguments: (identifier)))
    fields:
      (structure_field
        name: (identifier)
        type: (identifier))
    fields:
      (structure_field
        name: (identifier)
        type: (identifier))))

========
Instance
========

instance : ToString Foo where
  toString (d : Foo) : String := "Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters
            name: (identifier)
            type: (identifier))
        return_type: (identifier)
        body: (string))))

==============
Named Instance
==============

instance toStringFoo : ToString Foo where
  toString (d : Foo) : String := "Foo"

---

(module
  (instance
    name: (identifier)
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters
            name: (identifier)
            type: (identifier))
        return_type: (identifier)
        body: (string))))

===================================
Instance With Inductive Constructor
===================================

instance : Inhabited Nat := ⟨0⟩

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    body: (inductive_constructor (number))))

========================================
Instance Field With Function Return Type
========================================

instance : ToString Foo where
  toString : Foo → String := λ f => s!"Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        return_type:
          (function_annotation (identifier) (identifier))
        body:
          (lambda
            (parameters name: (identifier))
            (interpolated_string)))))

==================================
Instance Field Without Return Type
==================================

instance : ToString Foo where
  toString d := "Foo"

---

(module
  (instance
    class:
      (apply
        name: (identifier)
        arguments: (identifier))
    fields:
      (instance_field
        name: (identifier)
        parameters:
          (parameters name: (identifier))
        body: (string))))

=======
Example
=======

example : (fun x => x * 2) 4 < 3 = false := rfl

---

(module
  (example
    (binary_expression
      (comparison
        (apply
          (lambda (parameters (identifier))
            (binary_expression (identifier) (number))) (number))
        (number))
      (false))
    (identifier)))

==============
Inductive Type
==============

inductive FooBar where
  | foo    : Foo
  | bar    : Bar

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier)
        type: (identifier))
    constructors:
      (constructor
        name: (identifier)
        type: (identifier))))

=======================
Inductive Type One Line
=======================

inductive Bit | bit0 | bit1

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))
    constructors:
      (constructor
        name: (identifier))))

================================
Inductive Type Superfluous Where
================================

inductive Bit where | bit0 | bit1

---

(module
  (inductive_type
    name: (identifier)
    constructors:
      (constructor
        name: (identifier))
    constructors:
      (constructor
        name: (identifier))))
